const fetch = require('node-fetch');
const fs = require('fs');
const jsonToGo = require('../vendor/json-to-go.js');
const buildPath = require('./buildPath');
const {isJsonString, loadConfig, loadFile, loadJson, toPascalCase} = require("./common");

let cliOpts

function run(urlStr, body, options) {
  let comment, url, path, cfg
  cliOpts = options

  let opts = {}
  try {
    opts = buildOpts(body, cliOpts)
  } catch (e) {
    console.error(e.message);
    return
  }

  // See: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
  fetch(urlStr, opts)
    .then(res => {
      const apiUrl = urlStr.replace(/\/$/, '')
      url = new URL(apiUrl);
      cfg = loadConfig(url, cliOpts.config)
      path = buildPath(url, cliOpts.config, opts)

      console.log(`Status:  ${res.status} ${res.statusText}`)
      console.log(`Request: ${opts.method} ${url}`)
      if (path.path.pathFormat) console.log(`Format:  ${path.path.pathFormat}`)
      if (cfg?.["docs"] !== undefined) console.log(`Docs:    ${cfg?.["docs"].join(", ")}`)
      comment = buildComment(url, path, opts.method, res)

      return res.json()
    })
    .then(json => {
      let method = toPascalCase(opts?.method)
      const struct = jsonToGo(JSON.stringify(json), path.struct + method);
      const content = buildContent(struct.go, path, comment,"")
      write(json, path, content)

      if (opts?.body) {
        const bodyStruct = jsonToGo(opts?.body, path.struct + method + "Body");
        const bodyContent = buildContent(
            bodyStruct.go, path, buildComment(url, path, opts.method), "body"
        )
        writeBodyParam(JSON.stringify(JSON.parse(opts?.body), null, "\t"), path, bodyContent)
      }
      if (url?.search) {
        const queryJson = queryToJson(new URLSearchParams(url.search))
        const queryStr = JSON.stringify(queryJson, null, "\t")
        const queryStruct = jsonToGo(queryStr, path.struct + method + "Query");
        const queryContent = buildContent(
            queryStruct.go, path, buildComment(url, path, opts.method), "query"
        )
        writeQueryParam(queryStr, path, queryContent)
      }
    }, () => {
      console.log()
      console.log("Response Body is empty.")
    })
    .catch((error) => {
      console.error(error);
    });
}

function write(json, path, content) {
  fs.mkdirSync(path.dir, {recursive: true})
  fs.writeFile(path.jsonFilePath, JSON.stringify(json, null, "\t"), (err) => {
    if (err) throw err;
  });
  fs.writeFile(path.goFilePath, content, (err) => {
    if (err) throw err;
  });
  console.log()
  console.log("Response Body:")
  console.log(`  - ${path.goFilePath}:1`)
  console.log(`  - ${path.jsonFilePath}:1`)
}

function writeBodyParam(json, path, content) {
  fs.writeFile(path.bodyJsonFilePath, json, (err) => {
    if (err) throw err;
  });
  fs.writeFile(path.bodyGoFilePath, content, (err) => {
    if (err) throw err;
  });
  console.log()
  console.log("Request Body Parameter:")
  console.log(`  - ${path.bodyGoFilePath}:1`)
  console.log(`  - ${path.bodyJsonFilePath}:1`)
}

function writeQueryParam(json, path, content) {
  fs.writeFile(path.queryJsonFilePath, json, (err) => {
    if (err) throw err;
  });
  fs.writeFile(path.queryGoFilePath, content, (err) => {
    if (err) throw err;
  });
  console.log()
  console.log("Request Query Parameter:")
  console.log(`  - ${path.queryGoFilePath}:1`)
  console.log(`  - ${path.queryJsonFilePath}:1`)
}

function buildOpts(body, cliOpts) {
  const opts = {}
  if (cliOpts?.method) opts.method = cliOpts?.method
  if (cliOpts?.headers) {
    if (isJsonString(cliOpts.headers)) {
      opts.headers = JSON.parse(cliOpts.headers)
    } else {
      opts.headers = loadJson(cliOpts.headers)
    }
  }
  if (body) {
    if (!cliOpts?.method) {
      opts.method = "POST"
    }
    if (isJsonString(body)) {
      opts.body = body
    } else {
      const bodyObj = loadFile(body)
      if (!isJsonString(bodyObj)) {
        throw new Error(`${body} is not json file.`);
      }
      opts.body = bodyObj
    }
  }
  if (cliOpts?.debug) {
    if (opts) {
      console.error(opts)
      console.error()
    }
  }
  if (!opts?.method) opts.method = "GET"
  return opts
}

function buildContent(go, path, comment, paramType) {
  let content = `// Generated Code But Editable.
// Format The Code with \`go fmt\` or something and edit it manually to use it.
//
// Generated by: api-to-go (https://github.com/nkmr-jp/api-to-go).

`
  content += `package ${path.pkg}\n\n`
  if (go.indexOf('time.') !== -1) {
    content += `import "time"\n\n`
  }
  if (paramType === "body") {
    content += `// ${go.split(" ")[1]} is the struct of the HTTP Request Body Parameter.\n//`
  } else if (paramType === "query") {
    content += `// ${go.split(" ")[1]} is the struct of the HTTP Request Query Parameter.\n//`
  }else{
    content += `// ${go.split(" ")[1]} is the struct of the HTTP Response Body.\n//`
  }
  content += comment
  content += go
  return content
}

function buildComment(url, path, method, res = false) {
  let comment = ""
  if (res) {
    comment += `\n//\tStatus:  ${res.status} ${res.statusText}`
  }
  comment += `\n//\tRequest: ${method} ${url.href}`

  const cfg = loadConfig(url, cliOpts.config)
  if (path.path.pathFormat) {
    comment += `\n//\tFormat:  ${path.path.pathFormat}`
  }
  if (cfg?.["docs"] !== undefined) {
    comment += `\n//\tDocs:    ${cfg?.["docs"].join(", ")}`
  }
  return `${comment}\n`
}

function queryToJson(query) {
  const json = {}
  for (const [key, value] of query.entries()) {
    json[key] = value
  }
  return json
}

module.exports = run;